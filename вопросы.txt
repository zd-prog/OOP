1. Что такое сериализация, десериализация?

Сериализация (в программировании) — процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации 
(структуризации) — восстановление начального состояния структуры данных из битовой последовательности.

2. Какие существуют форматы сериализации? Поясните структуру для каждого формата. Какие классы для работы с ними существуют в .NET?

бинарный

SOAP

xml

JSON

Для каждого формата предусмотрен свой класс: для сериализации в бинарный формат - класс BinaryFormatter, для формата SOAP - класс SoapFormatter, для xml - XmlSerializer, для json - 
DataContractJsonSerializer. 

3. Какие классы существуют в пространстве имен System.Xml?

XmlNode: представляет узел xml. В качестве узла может использоваться весь документ, так и отдельный элемент

XmlDocument: представляет весь xml-документ

XmlElement: представляет отдельный элемент. Наследуется от класса XmlNode

XmlAttribute: представляет атрибут элемента

XmlText: представляет значение элемента в виде текста, то есть тот текст, который находится в элементе между его открывающим и закрывающим тегами

XmlComment: представляет комментарий в xml

XmlNodeList: используется для работы со списком узлов

4. Какие атрибуты используются для настройки XML сериализации?

XmlAnyAttributeAttribute	Открытое поле, свойство, параметр или возвращаемое значение, которое возвращает массив объектов XmlAttribute.	Во время десериализации массив будет заполняться объектами XmlAttribute, представляющими все атрибуты XML, не известные для схемы.
XmlAnyElementAttribute	Открытое поле, свойство, параметр или возвращаемое значение, которое возвращает массив объектов XmlElement.	Во время десериализации массив заполняется объектами XmlElement, представляющими все элементы XML, не известные для схемы.
XmlArrayAttribute	Открытое поле, свойство, параметр или возвращаемое значение, которое возвращает массив сложных объектов.	Члены массива создаются как члены массива XML.
XmlArrayItemAttribute	Открытое поле, свойство, параметр или возвращаемое значение, которое возвращает массив сложных объектов.	Производные типы, которые могут быть размещены в массиве. Обычно используется совместно с XmlArrayAttribute.
XmlAttributeAttribute	Открытое поле, свойство, параметр или возвращаемое значение.	Член должен быть сериализован как атрибут XML.
XmlChoiceIdentifierAttribute	Открытое поле, свойство, параметр или возвращаемое значение.	Член может быть однозначно определен перечислением.
XmlElementAttribute	Открытое поле, свойство, параметр или возвращаемое значение.	Поле или свойство сериализуется как элемент XML.
XmlEnumAttribute	Открытое поле, являющееся идентификатором перечисления.	Имя элемента члена перечисления.
XmlIgnoreAttribute	Открытые свойства и поля.	Свойство или поле должно игнорироваться при сериализации содержащего его класса.
XmlIncludeAttribute	Объявления открытых производных классов и возвращаемые значения открытых методов для документов WSDL.	При создании схем класс должен быть включен (чтобы его можно было распознать во время сериализации).
XmlRootAttribute	Объявления открытых классов.	Управляет XML-сериализацией конечного объекта атрибута как корневого XML-элемента. Используйте атрибут, чтобы подробнее указать пространство имен и имя элемента.
XmlTextAttribute	Открытые свойства и поля.	Свойство или поле сериализуется как текст XML.
XmlTypeAttribute	Объявления открытых классов.	Имя и пространство имен типа XML.

5. В чем отличие BinaryFormatter или SoapFormatter?

Здесь заключается основной минус BinaryFormatter - данные, сохраненные с его помощью, могут быть воссозданы только в инфраструктуре CLI.
В отличие от BinaryFormatter, платформа и операционная система не влияют на успешное восстановление данных, сериализированных с помощью SoapFormatter.

6. Что такое сериализация контрактов данных, контракт данных?

Контракт данных – это тип (класс или структура), объект которого описывает информационный фрагмент. 

7. Где и для чего используются атрибуты [OnSerializing], [OnSerialized], [OnDeserializing], [OnDeserialized]?

[OnSerializing]	Этот атрибут позволяет указать метод, который будет вызван перед процессом сериализации
[OnSerialized]	Этот атрибут позволяет указать метод, который будет вызван немедленно после того, как объект сериализован
[OnDeserialized]	Этот атрибут позволяет указать метод, который будет вызван немедленно после десериализации объекта
[OnDeserializing]	Этот атрибут позволяет указать метод, который будет вызван перед процессом десериализации

8. Что такое XPath? Приведите пример.

XPath определяет синтаксис для определения частей документа XML;
XPath использует выражения пути для навигации по элементам XML-документов;
XPath содержит библиотеку стандартных функций;
XPath является одним из основных элементов в XSLT;
XPath является рекомендацией W3C.

XPath представляет язык запросов в XML.

XmlDocument xDoc = new XmlDocument();
xDoc.Load("D://users.xml");
XmlElement xRoot = xDoc.DocumentElement;
 
// выбор всех дочерних узлов
XmlNodeList childnodes = xRoot.SelectNodes("*");
foreach (XmlNode n in childnodes)
    Console.WriteLine(n.OuterXml);

9. Какие возможности дает LINQ to Xml. Приведите примеры



1. Что такое процесс, домен, поток? Как они связаны между собой?

Проце́сс — выполнение пассивных инструкций компьютерной программы на процессоре ЭВМ.
При запуске приложения, написанного на C#, операционная система создает процесс, а среда CLR создает внутри этого процесса логический контейнер, который называется доменом приложения и 
внутри которого работает запущенное приложение. Поток данных (англ. stream) в программировании — абстракция, используемая для чтения или записи файлов, сокетов и т. п. в единой манере.

2. Как получить информацию о процессах?

В .NET процесс представлен классом Process из пространства имен System.Diagnostics. Этот класс позволяет управлять уже запущенными процессами, а также запускать новые. В данном классе определено ряд свойств и методов, позволяющих получать информацию о процессах и управлять ими:

Свойство Handle: возвращает дескриптор процесса

Свойство Id: получает уникальный идентификатор процесса в рамках текущего сеанса ОС

Свойство MachineName: возвращает имя компьютера, на котором запущен процесс

Свойство Modules: получает доступ к коллекции ProcessModuleCollection, которая хранит набор модулей (файлов dll и exe), загруженных в рамках данного процесса

Свойство ProcessName: возвращает имя процесса, которое нередко совпадает с именем приложения

Свойство StartTime: возвращает время, когда процесс был запущен

Свойство VirtualMemorySize64: возвращает объем памяти, который выделен для данного процесса

Метод CloseMainWindow(): закрывает окно процесса, который имеет графический интерфейс

Метод GetProcesses(): возвращающий массив всех запущенных процессов

Метод GetProcessesByName(): возвращает процессы по его имени. Так как можно запустить несколько копий одного приложения, то возвращает массив

Метод Kill(): останавливает процесс

Метод Start(): запускает новый процесс

3. Как создать и настроить домен?

Создать домен приложения можно с помощью одного из перегруженных методов CreateDomain в классе System.AppDomain.

4. Как создать и настроить поток?

Для создания нового потока используется делегат ThreadStart, который получает в качестве параметра метод, который мы определил выше.

И чтобы запустить поток, вызывается метод Start.

5. В каких состояниях может быть поток?

Поток может находиться в одном из трех основных состояний:

- выполнение — активное состояние потока, во время которого поток обладает всеми необходимыми ресурсами и непосредственно выполняется процессором;

- ожидание — пассивное состояние потока, находясь в котором, поток заблокирован по своим внутренним причинам (ждет осуществления некоторого события, например завершения операции 
ввода-вывода, получения сообщения от другого потока или освобождения какого-либо необходимого ему ресурса);

- готовность — также пассивное состояние потока, но в этом случае поток заблокирован в связи с внешним по отношению к нему обстоятельством (имеет все требуемые для него ресурсы, готов 
выполняться, однако процессор занят выполнением другого потока).

6. Какие методы управления потоками вы знаете, для чего и как их использовать?

Некоторые методы класса Thread:

Статический метод GetDomain возвращает ссылку на домен приложения

Статический метод GetDomainID возвращает id домена приложения, в котором выполняется текущий поток

Статический метод Sleep останавливает поток на определенное количество миллисекунд

Метод Abort уведомляет среду CLR о том, что надо прекратить поток, однако прекращение работы потока происходит не сразу, а только тогда, когда это становится возможно. Для проверки завершенности потока следует опрашивать его свойство ThreadState

Метод Interrupt прерывает поток на некоторое время

Метод Join блокирует выполнение вызвавшего его потока до тех пор, пока не завершится поток, для которого был вызван данный метод

Метод Start запускает поток

7. Какие приоритеты потока вы знаете?

AboveNormal
3
Выполнение потока Thread может быть запланировано после выполнения потоков с приоритетом Highest и до потоков с приоритетом Normal.
BelowNormal
1
Выполнение потока Thread может быть запланировано после выполнения потоков с приоритетом Normal и до потоков с приоритетом Lowest.
Highest
4
Выполнение потока Thread может быть запланировано до выполнения потоков с любыми другими приоритетами.
Lowest
0
Выполнение потока Thread может быть запланировано после выполнения потоков с любыми другими приоритетами.
Normal
2
Выполнение потока Thread может быть запланировано после выполнения потоков с приоритетом AboveNormal и до потоков с приоритетом BelowNormal. По умолчанию потоки имеют приоритет Normal.

8. Что такое пул потоков и для чего он используется?

Пул потоков – автоматизированный ссылочный тип-контейнер ссылок на рабочие потоки на языке C#. Определен в пространстве имен библиотеки типов System.Treading. По сути выполняет роль 
посредника между планировщиком задач операционной системы и потоками, реализованными в рамках .NET-платформы, так как связывает дескрипторы операционной системы с собственными.

9. Что такое критическая секция? Поясните использование.

Критическая секция (Critical Section) это участок кода, в котором поток (thread) получает доступ к ресурсу (например переменная), который доступен из других потоков.

10.Что такое мьютекс? Поясните использование

Мью́текс (англ. mutex, от mutual exclusion — «взаимное исключение») — примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода.

11.Что такое семафор? Поясните использование

Семафо́р (англ. semaphore) — примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и 
уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся.

12.Что такое неблокирующие средства синхронизации?

Неблокирующая синхронизация — подход в параллельном программировании на симметрично-многопроцессорных системах, в котором принят отказ от традиционных примитивов блокировки, таких, как 
семафоры, мьютексы и события.

13.Для чего можно использовать класс Timer?

Данный класс позволяет запускать определенные действия по истечению некоторого периода времени.


1. Что такое TPL? Как и для чего используется тип Task

Библиотека параллельных задач TPL. В основе библиотеки TPL лежит концепция задач, каждая из которых описывает отдельную продолжительную операцию. В библиотеке классов .NET задача 
представлена специальным классом - классом Task, который находится в пространстве имен System.Threading.Tasks. Данный класс описывает отдельную задачу, которая запускается асинхронно в 
одном из потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке.

2. Почему эффект от распараллеливания наблюдается на большом количестве элементов?

3. В чем основные достоинства работы с задачами по сравнению с потокми?

Важное отличие заключается в том, что вызов метода Start для задачи не создает новый поток, а помещает задачу в очередь готовых задач – пул потоков. Планировщик (TaskScheduler) в 
соответствии со своими правилами распределяет готовые задачи по рабочим потокам. Действия планировщика можно корректировать с помощью параметров задач. Момент фактического запуска задачи в 
общем случае не определен и зависит от загруженности пула потоков.

4. Приведите три способа создания и/или запуска Task?

// Create a task but do not start it.
        Task t1 = new Task(action, "alpha");

        // Construct a started task
        Task t2 = Task.Factory.StartNew(action, "beta");
        // Block the main thread to demonstrate that t2 is executing
        t2.Wait();

        // Launch t1 
        t1.Start();
        Console.WriteLine("t1 has been launched. (Main Thread={0})",
                          Thread.CurrentThread.ManagedThreadId);
        // Wait for the task to finish.
        t1.Wait();

        // Construct a started task using Task.Run.
        String taskData = "delta";
        Task t3 = Task.Run( () => {Console.WriteLine("Task={0}, obj={1}, Thread={2}",
                                                     Task.CurrentId, taskData,
                                                      Thread.CurrentThread.ManagedThreadId);
                                   });
        // Wait for the task to finish.
        t3.Wait();

        // Construct an unstarted task
        Task t4 = new Task(action, "gamma");
        // Run it synchronously
        t4.RunSynchronously();
        // Although the task was run synchronously, it is a good practice
        // to wait for it in the event exceptions were thrown by the task.
        t4.Wait();

5. Как и для чего используют методы Wait(), WaitAll() и WaitAny()?

 метод Wait(), приостанавливающий исполнение вызывающего потока до тех пор, пока не завершится вызываемая задача.
WaitAll(). Этот метод организует ожидание завершения группы задач. Возврата из него не произойдет до тех пор, пока не завершатся все задачи.
Иногда требуется организовать ожидание до тех пор, пока не завершится любая из группы задач. Для этой цели служит метод WaitAny(). 

6. Приведите пример синхронного запуска Task?

Task t4 = new Task(action, "gamma");
        // Run it synchronously
        t4.RunSynchronously();
        // Although the task was run synchronously, it is a good practice
        // to wait for it in the event exceptions were thrown by the task.
        t4.Wait();

7. Как создать задачу с возвратом результата?

Для того чтобы возвратить результат из задачи, достаточно создать эту задачу, используя обобщенную форму Task<TResult> класса Task.

8. Как обработать исключение, если оно произошло при выполнении Task?

 var task1 = Task.Run( () => { throw new CustomException("This exception is expected!"); } );

      try
      {
          task1.Wait();
      }
      catch (AggregateException ae)
      {
          foreach (var e in ae.InnerExceptions) {
              // Handle the custom exception.
              if (e is CustomException) {
                  Console.WriteLine(e.Message);
              }
              // Rethrow any other exception.
              else {
                  throw;
              }
          }

9. Что такое CancellationToken и как с его помощью отменить выполнение задач?

Параллельное выполнение задач может занимать много времени. И иногда может возникнуть необходимость прервать выполняемую задачу. Для этого .NET предоставляет класс CancellationToken
Для отмены операции нам надо создать и использовать токен. Вначале создается объект CancellationTokenSource:

CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
Затем из него получаем сам токен:

CancellationToken token = cancelTokenSource.Token;
Чтобы отменить операцию, необходимо вызвать метод Cancel() у объекта CancellationTokenSource:

cancelTokenSource.Cancel();

10.Как организовать задачу продолжения (continuation task) ?

Задачи продолжения или continuation task позволяют определить задачи, которые выполняются после завершения других задач.
задача продолжения задается с помощью метода ContinueWith, который в качестве параметра принимает делегат Action<Task>.

11.Как и для чего используется объект ожидания при создании задач продолжения?

Ожидаемый тип должен иметь публичный (или internal) метод GetAwaiter(), это может быть и метод расширения. Этот метод возвращает объект ожидания
Объект ожидания должен реализовать интерфейс INotifyCompletion, который обязывает реализовать метод void OnCompleted(Action continuation). Также он должен иметь экземплярные свойство bool 
IsCompleted, метод void GetResult(). Может быть как структурой, так и классом.

12.Поясните назначение класса System.Threading.Tasks.Parallel?

Этот класс поддерживает набор методов, которые позволяют выполнять итерации по коллекции данных (точнее, по объектам, реализующим IEnumerable<T>) в параллельном режиме.

13.Приведите пример задачи с Parallel.For(int, int, Action<int>)

Метод Parallel.For позволяет выполнять итерации цикла параллельно. Он имеет следующее определение: For(int, int, Action<int>), где первый параметр задает начальный индекс элемента в цикле, а второй параметр - конечный индекс. Третий параметр - делегат Action - указывает на метод, который будет выполняться один раз за итерацию:


static void Main(string[] args)
{
    Parallel.For(1, 10, Factorial);
 
    Console.ReadLine();
}
 
static void Factorial(int x)
{
    int result = 1;
 
    for (int i = 1; i <= x; i++)
    {
        result *= i;
    }
    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
    Console.WriteLine($"Факториал числа {x} равен {result}");
    Thread.Sleep(3000);
}

14.Приведите пример задачи с Parallel.ForEach

Метод Parallel.ForEach осуществляет итерацию по коллекции, реализующей интерфейс IEnumerable, подобно циклу foreach, только осуществляет параллельное выполнение перебора. Он имеет следующее 
определение: ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,Action<TSource> body), где первый параметр представляет перебираемую коллекцию, а второй параметр - делегат, 
выполняющийся один раз за итерацию для каждого перебираемого элемента коллекции.

static void Main(string[] args)
{
    ParallelLoopResult result = Parallel.ForEach<int>(new List<int>() { 1, 3, 5, 8 },
                Factorial);
 
    Console.ReadLine();
}
static void Factorial(int x)
{
    int result = 1;
 
    for (int i = 1; i <= x; i++)
    {
        result *= i;
    }
    Console.WriteLine($"Выполняется задача {Task.CurrentId}");
    Console.WriteLine($"Факториал числа {x} равен {result}");
    Thread.Sleep(3000);
}

15.Приведите пример с Parallel.Invoke()

Метод Invoke позволяет выполнение задач параллельно (на разных ядрах процесора).
class Program
{
     static void Main(string[] args)
     {
          Parallel.Invoke(
          // метод 1
          Display,

          // метод 2
          () => {
               Console.WriteLine("Выполняется задача {0}", Task.CurrentId);
               Thread.Sleep(3000);
          },

          // метод 3
          () => MySum(200));

          Console.ReadLine();
     }

     static void Display()
     {
          Console.WriteLine("Выполняется задача {0}", Task.CurrentId);
          Thread.Sleep(2000);
     }

     static void MySum(int x)
     {
          int result = 1;

          for (int i = 1; i <= x; i++)
          {
               result += i;
          }
          Console.WriteLine("Выполняется задача {0}", Task.CurrentId);
          Thread.Sleep(2000);
          Console.WriteLine("Результат {0}", result);
     }
}

16.Как с использованием CancellationToken отменить параллельные операции?

Для отмены выполнения параллельных операций, запущенных с помощью методов Parallel.For() и Parallel.ForEach(), можно использовать перегруженные версии данных методов, которые принимают в 
качестве параметра объект ParallelOptions. Данный объект позволяет установить токен

17.Для чего используют BlockingCollection<T>, в чем ее особенность?

BlockingCollection<T> — это потокобезопасный класс коллекции, обеспечивающий следующие возможности:
реализует шаблон "производитель-получатель";
поддерживает параллельное добавление и извлечение элементов из нескольких потоков;
допускает указание максимальной емкости;
поддерживает операции вставки и удаления, блокирующиеся при опустошении или заполнении коллекции;
поддерживает условные операции вставки и удалении, не блокирующиеся или блокирующиеся лишь на определенное время;
инкапсулирует все типы коллекций, реализующие интерфейс IProducerConsumerCollection<T>;
поддерживает отмену с помощью токенов отмены;
поддерживает два вида перечисления с помощью оператора foreach (For Each в Visual Basic):
перечисление "только для чтения";
перечисление, при котором элементы по мере перечисления удаляются.

18.Как используя async и await организовать асинхронное выполенение метода?
Ключевыми для работы с асинхронными вызовами в C# являются два ключевых слова: async и await, цель которых - упростить написание асинхронного кода. Они используются вместе для создания 
асинхронного метода.

static async void FactorialAsync()
        {
            Console.WriteLine("Начало метода FactorialAsync"); // выполняется синхронно
            await Task.Run(()=>Factorial());                // выполняется асинхронно
            Console.WriteLine("Конец метода FactorialAsync");
        }